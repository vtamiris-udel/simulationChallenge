---
title: "Simulation Challenge"
subtitle: "Starter Template with To-Dos"
format:
  html: default
execute:
  echo: true
  eval: true
---

# ðŸŽ² Simulation Challenge

## The Investment Game (Brief)

You have the opportunity to buy-in to this game next week with \$30,000. Your job is to analyze the potential outcomes of the game and communicate why or why you should not buy-in to the game.

Each year after buy-in you flip a fair coin:

-   Heads: increase your account balance by 50%
-   Tails: decrease your account balance by 40%

You play annually until age 75. Your mission is to analyze outcomes and communicate insights clearly.

### Generative DAG Model (from the source challenge)

The following DAFT diagram shows the generative structure of the investment game over time.

```{python}
#| echo: false
#| include: false
import daft

# Create the DAG directly without custom class
investmentDAG = daft.PGM(dpi=100, alternate_style="outer")

# Initial wealth (deterministic)
investmentDAG.add_node("W0", "Initial Wealth\n$W_0 = 30,000$", x=4, y=2.5, aspect=5.4, 
                      alternate=True, plot_params={'facecolor': 'aliceblue'})

# Time t nodes  
investmentDAG.add_node("Ct", "Coin Flip t\n$C_t \\sim \\text{Bernoulli}(0.5)$", x=0, y=1, aspect=4, scale = 1.6,
                      plot_params={'facecolor': 'aliceblue'})
investmentDAG.add_node("Wt", "\nWealth t\n$W_t = 1.5 \\times W_{t-1}$ if $C_t = 1$\n$W_t = 0.6 \\times W_{t-1}$ if $C_t = 0$\n", x=4, y=1, scale = 1.6, aspect=4,
                      alternate=True, plot_params={'facecolor': 'aliceblue'})

# Add edges showing the relationships
investmentDAG.add_edge("W0", "Wt")
investmentDAG.add_edge("Ct", "Wt")

# Add plate around time-dependent nodes
investmentDAG.add_plate([-2, 0.5, 7.8, 1.0], label="t = 1, ..., N", shift=-0.1)
```

```{python}
#| label: fig-investment-dag
#| fig-cap: Generative DAG model for the investment game showing how wealth evolves over time through coin flips
#| echo: false
investmentDAG.show()
```

## Analysis Tasks (Fill These In)

::: callout-note
## Grading Scope

-   Sections 1â€“4: required and can earn up to 90% of the grade.
-   Sections 5â€“6: optional; strong, well-supported work here can bring your score up to 100%.
:::

### 1) Expected Value After 1 Flip

TODO: Explain whether the expected value of your account balance after one flip is \>, =, or \< \$30,000. What is the gain in expected value as a percentage of your buy-in? Does this simple analysis suggest you should buy-in to the game?

```{python}
#| label: q1-expected-value-py
#| echo: false

# TODO: Compute EV after one flip in Python
# - Show calculation and brief explanation
W0 = 30_000 #initial wealth
p = 0.5 #
u = 1.5
d = 0.6

E_W1 = W0 * (p * u + (1 - p) * d)
#print(E_W1)  # 31500.0

#if Ct=0
E_W1_given_C0=W0*d
#print(E_W1_given_C0)

```

Expected output after one flip will be either \$31500 if head is the outcome. Balance will be decreased to \$18000 if tails is the outcome.

### 2) Single Simulation Over Time (Narrative + Plot)

Briefly narrate and visualize what happens to your account balance over the course of one run. Are you happy with the outcome? Why? or Why not? You can use a time series plot to visualize the changes in your account balance over time.

####  Narrative

-   The balance **jumped early** with a streak of Heads (50% gains).

-   Then several Tails caused big drops â€” when you lose **40%**, you need **+67%** just to recover back.

-   The run continued oscillating, sometimes recovering, sometimes losing momentum.

-   There were moments when the balance looked like it was exploding upwardâ€¦ and then a Tails would crush progress.

In this specific run:

-   Starting balance: **\$30,000**

    Peak balance reached: **over \$120,000**

    Ending balance (age 75): *it ended below earlier peaks*

The takeaway:

> Even a â€œgoodâ€ run with several lucky heads early was highly volatile and emotionally chaotic.

```{python}
#| label: q2-single-sim-py
#| echo: false
#| fig-cap: "Single simulation path of account balance"

# TODO: Simulate one path from $30,000 over N periods
# - Make a matplotlib (OO) time-series
# - Set seed for reproducibility

#| label: one-run-simulation
#| fig-cap: One run of the coin-flip game (log scale)
import numpy as np
import matplotlib.pyplot as plt

W0 = 30_000
u, d, p = 1.5, 0.6, 0.5
start_age = 35       # â† set your current age
end_age = 75
N = end_age - start_age

rng = np.random.default_rng(42)  # â† set seed for a reproducible run
Ct = rng.binomial(1, p, size=N)  # 1=heads, 0=tails
multipliers = np.where(Ct == 1, u, d)

wealth = W0 * np.cumprod(np.r_[1, multipliers])  # length N+1
ages = np.arange(start_age, end_age + 1)

heads = Ct.sum()
tails = N - heads
final = wealth[-1]
cagr = (final / W0) ** (1 / N) - 1 if N > 0 else np.nan
peak = np.maximum.accumulate(wealth)
max_drawdown = np.max(1 - wealth / peak)

print(f"Years: {N}, Heads: {heads}, Tails: {tails}")
print(f"Final balance: ${final:,.2f} | CAGR: {cagr:.2%} | Max drawdown: {max_drawdown:.2%}")

fig, ax = plt.subplots(figsize=(5,4))
ax.plot(ages, wealth, color="#3366cc", lw=2)
ax.axhline(W0, color="#075a6eff", ls="--", lw=1, label="Initial balance")
ax.set_title("One Run of the Coin-Flip Game")
ax.set_xlabel("Age")
ax.set_ylabel("Account Balance ($)")
ax.set_yscale("linear")  # multiplicative changes read better on log scale
ax.legend()
ax.grid(True, alpha=0.3)
plt.show()


```

### ðŸ¤” Are you happy with this outcome?

**Personally â€” No.**

Why?

-   The results are dominated by **luck and volatility**, not skill.

-   Losses hurt multiplicatively â€” a â€“40% loss destroys far more progress than a +50% gain adds.

-   A few bad flips wipe out years of gains.

-   Your account behaves like a **rollercoaster with no brakes**.

Even though the upside is huge **in theory**, the *median*, or â€œmost common,â€ outcome is losing money.

### 3) 100 Simulations: Distribution of Final Balances

TODO: Visually and narratively describe the distribution of your account balance after running the 100 simulations. What is the probability of outcomes that you'd be happy with after having invested \$30,000?

```{python}
#| label: q3-dist-100-py
#| echo: false
#| fig-cap: "Distribution of final balances across 100 simulations"

# TODO: Run 100 simulations and plot histogram of final balances
# - Add vertical line at $30,000
# - Compute mean, median, and P(final > $30,000)
#| label: hundred-run-dist
#| fig-cap: Distribution of final balances over 100 runs
import numpy as np
import matplotlib.pyplot as plt

# Parameters
initial_balance = 30000.0
start_age = 35
end_age = 75
years = end_age - start_age
sims = 100

np.random.seed(123)
paths = []

for _ in range(sims):
    balance = initial_balance
    yearly = [balance]
    for _ in range(years):
        flip = np.random.choice(["H", "T"], p=[0.5, 0.5])
        balance = balance * 1.5 if flip == "H" else balance * 0.6
        yearly.append(balance)
    paths.append(yearly)

ages = list(range(start_age, end_age + 1))

plt.figure(figsize=(8,6))

for p in paths:
    plt.plot(ages, p, alpha=0.35)  # transparent lines

plt.title("Spaghetti Plot â€” 100 Account Balance Paths (Age 35 â†’ 75)")
plt.xlabel("Age")
plt.ylabel("Account Balance ($)")
plt.grid(True)
plt.show()


```

The distribution is **wildly skewed** and **highly asymmetric**:

-   In the **majority of the 100 runs**, your ending balance collapses.

-   The median (typical) final balance is **well below your starting \$30,000**.

-   Very few â€œlucky streakâ€ paths create enormous balances â€” but those outliers pull the average up.

> In plain English:\
>
> **Most people lose. A few get insanely rich.**

This is why:

-   The **mean** (average) looks high (pulled up by million-dollar jackpots),

-   But the **median** (what youâ€™re likely to experience) is very low.

This behavior is classic **â€œlottery distributionâ€** â€” many losers, few giant winners.

### 4) Probability Balance \> \$30,000 at Age 75 (Original Game)

TODO: Report the probability estimate and interpret its practical meaning.

```{python}
#| label: q4-prob-original-py
#| echo: false

# TODO: Using the 100 simulations above, estimate P(final > 30000)
# - Print numeric result with 3 decimals
import numpy as np
import pandas as pd

# Parameters
initial_balance = 30000.0
start_age = 35
end_age = 75
years = end_age - start_age
sims = 100

np.random.seed(123)  # reproducible for demonstration

# Run 100 simulations & store each final balance
final_balances = []

for _ in range(sims):
    balance = initial_balance
    for _ in range(years):
        flip = np.random.choice(["H", "T"], p=[0.5, 0.5])
        balance = balance * 1.5 if flip == "H" else balance * 0.6
    final_balances.append(balance)

# Store results in DataFrame
df = pd.DataFrame({"Final_Balance": final_balances})

# Calculate probability of success (ending > original investment)
probability = (df["Final_Balance"] > initial_balance).mean()

print(f"Probability of balance over 30000 is {probability}")

```

### 5) Modified Strategy (Bet Exactly 50% Each Round)

Instead of having the full balance at risk with each coin flip, assume only 25% of your balance is gambled each year. Compare this to the original game. Which is riskier? Which has better upside?

```{python}
#| label: q5-modified-50pct-py
#| echo: false
#| fig-cap: "Modified strategy distribution (bet 50% each round)"

# TODO: Implement the modified game
# - Run 100 simulations; plot distribution of final balances
# - Estimate P(final > 30000) and compare to original
# - visually compare the outcome distributions of the original and modified strategies
# Single-cell Jupyter: compare "100% at risk" vs "25% gambled" strategies
# Paste this whole block into one notebook cell and run.
# Requires: numpy, pandas, matplotlib
# pip install numpy pandas matplotlib

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from IPython.display import display

# ---------------------------
# Parameters (changeable)
# ---------------------------
INITIAL_BALANCE = 30000.0
START_AGE = 35
END_AGE = 75
YEARS = END_AGE - START_AGE  # 40 flips
N_SIMS = 100
SEED = 2025
SAMPLE_SPAGHETTI = 40  # number of sample paths to plot in spaghetti

np.random.seed(SEED)

# ---------------------------
# Multipliers
# ---------------------------
# Original: 100% at risk -> H: x1.5, T: x0.6
orig_h, orig_t = 1.5, 0.6

# Modified: only 25% gambled, 75% safe
# new_balance = 0.75*balance + 0.25*balance*f  => multiplier = 0.75 + 0.25*f
mod_h = 0.75 + 0.25 * orig_h  # 1.125
mod_t = 0.75 + 0.25 * orig_t  # 0.90

# ---------------------------
# Run simulations
# ---------------------------
orig_final = np.empty(N_SIMS)
mod_final = np.empty(N_SIMS)
orig_paths = np.empty((N_SIMS, YEARS + 1))
mod_paths = np.empty((N_SIMS, YEARS + 1))

for i in range(N_SIMS):
    b_o = INITIAL_BALANCE
    b_m = INITIAL_BALANCE
    orig_paths[i, 0] = b_o
    mod_paths[i, 0] = b_m
    flips = np.random.randint(0, 2, size=YEARS)  # 0 -> H, 1 -> T
    for t, flip in enumerate(flips, start=1):
        if flip == 0:
            b_o *= orig_h
            b_m *= mod_h
        else:
            b_o *= orig_t
            b_m *= mod_t
        orig_paths[i, t] = b_o
        mod_paths[i, t] = b_m
    orig_final[i] = b_o
    mod_final[i] = b_m

# ---------------------------
# Summaries
# ---------------------------
def summarize(arr, initial=INITIAL_BALANCE):
    s = {
        "mean": arr.mean(),
        "median": np.median(arr),
        "std": arr.std(),
        "p_gt_initial": (arr > initial).mean(),
        "p_ge_100k": (arr >= 100000).mean(),
        "p_lt_10k": (arr < 10000).mean(),
        "1%ile": np.percentile(arr, 1),
        "5%ile": np.percentile(arr, 5),
        "25%ile": np.percentile(arr, 25),
        "50%ile": np.percentile(arr, 50),
        "75%ile": np.percentile(arr, 75),
        "90%ile": np.percentile(arr, 90),
        "95%ile": np.percentile(arr, 95),
        "99%ile": np.percentile(arr, 99),
    }
    return s

orig_stats = summarize(orig_final)
mod_stats = summarize(mod_final)

comp_df = pd.DataFrame([
    {
        "Strategy": "Original (100% at risk)",
        "Mean": orig_stats["mean"],
        "Median": orig_stats["median"],
        "StdDev": orig_stats["std"],
        "P(final > $30k)": orig_stats["p_gt_initial"],
        "P(final >= $100k)": orig_stats["p_ge_100k"],
        "P(final < $10k)": orig_stats["p_lt_10k"],
        "90%ile": orig_stats["90%ile"],
        "99%ile": orig_stats["99%ile"],
    },
    {
        "Strategy": "Modified (25% gambled)",
        "Mean": mod_stats["mean"],
        "Median": mod_stats["median"],
        "StdDev": mod_stats["std"],
        "P(final > $30k)": mod_stats["p_gt_initial"],
        "P(final >= $100k)": mod_stats["p_ge_100k"],
        "P(final < $10k)": mod_stats["p_lt_10k"],
        "90%ile": mod_stats["90%ile"],
        "99%ile": mod_stats["99%ile"],
    }
])

# Format percentages & currency for display
# df_display = comp_df.copy()
# df_display[["Mean","Median","StdDev","90%ile","99%ile"]] = df_display[["Mean","Median","StdDev","90%ile","99%ile"]].applymap(lambda x: f"${x:,.2f}")
# df_display[["P(final > $30k)","P(final >= $100k)","P(final < $10k)"]] = df_display[["P(final > $30k)","P(final >= $100k)","P(final < $10k)"]].applymap(lambda x: f"{x*100:.2f}%")

#print("Summary comparison ({} sims)".format(N_SIMS))
#display(df_display)

# ---------------------------
# Plot 1: Median paths over time
# ---------------------------
ages = np.arange(START_AGE, END_AGE + 1)
orig_median_path = np.median(orig_paths, axis=0)
mod_median_path = np.median(mod_paths, axis=0)

plt.figure(figsize=(7,5))
plt.plot(ages, orig_median_path, label="Original (100% at risk)", linewidth=2, color="tab:orange")
plt.plot(ages, mod_median_path, label="Modified (25% gambled)", linewidth=2, color="tab:blue")
plt.axhline(INITIAL_BALANCE, color="gray", linestyle="--", linewidth=1, label="Initial balance")
plt.title("Median Account Balance Over Time (Age {} â†’ {})".format(START_AGE, END_AGE))
plt.xlabel("Age")
plt.ylabel("Balance ($)")
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

# ---------------------------
# Plot 2: ECDFs of final balances (log inset for tails)
# ---------------------------

# def ecdf(x):
#     sx = np.sort(x)
#     y = np.arange(1, len(x) + 1) / len(x)
#     return sx, y

# sx_o, y_o = ecdf(orig_final)
# sx_m, y_m = ecdf(mod_final)

# plt.figure(figsize=(10,6))
# plt.plot(sx_o, y_o, marker='.', linestyle='none', alpha=0.6, label='Original (100% at risk)')
# plt.plot(sx_m, y_m, marker='.', linestyle='none', alpha=0.6, label='Modified (25% gambled)')
# plt.xscale('symlog')  # symmetric log to show small cluster and tail (handles zeros)
# plt.axvline(INITIAL_BALANCE, color='k', linestyle='--', label='Initial balance')
# plt.xlabel("Final balance ($) â€” symlog scale")
# plt.ylabel("Cumulative probability")
# plt.title("ECDF of Final Balances (symlog x-axis)")
# plt.legend()
# plt.grid(True)
# plt.tight_layout()
# plt.show()

# ---------------------------
# Plot 3: Spaghetti sample (overlay a subset for readability)
# ---------------------------
sample_idx = np.random.choice(N_SIMS, size=min(SAMPLE_SPAGHETTI, N_SIMS), replace=False)

fig, axes = plt.subplots(1,2, figsize=(8,5), sharey=True)
for idx in sample_idx:
    axes[0].plot(ages, orig_paths[idx], alpha=0.5, color='tab:orange')
    axes[1].plot(ages, mod_paths[idx], alpha=0.5, color='tab:blue')

axes[0].set_title("Spaghetti â€” Original (100% at risk)")
axes[1].set_title("Spaghetti â€” Modified (25% gambled)")
for ax in axes:
    ax.set_xlabel("Age")
axes[0].set_ylabel("Balance ($)")
axes[0].grid(True); axes[1].grid(True)
plt.tight_layout()
plt.show()
```

**Narrative:**

-   **Riskier:** **Original (100% at risk)** â€” far higher volatility and a much larger chance of catastrophic loss.

-   **Better *extreme* upside:** **Original** â€” the right-tail (jackpots) is much thicker; mean and 99th percentile are huge.

-   **Better practical/upside-for-most:** **Modified (25% gambled)** â€” far higher chance of finishing above your starting \$30k and far lower chance of ruin.

### 6) Briefly Explain Your Findings From The Previous Step in Light of A Concept Known as the "Kelly Criterion"

What is the Kelly Criterion and how does it relate to the modified strategy?

The Kelly Criterion is a position-sizing rule from probability theory and finance. It states:

-   To maximize long-term growth, you should only bet the fraction of your bankroll that maximizes the expected logarithmic growth rate.

Kelly tells us not to bet the full amount, even in a favorable game, because:

-   Gains compound multiplicatively.
-   Losses hurt more than equivalent gains help.

Mathematically:

Gain +50% then lose 40% â†’ you donâ€™t end at break-even â€” you end down 10%.

The original game (betting 100%) violates Kellyâ€™s guidance â€” youâ€™re overbetting, which drives your balance toward ruin. In contrast, betting only 25% of the balance each year is much closer to the Kelly-optimal fraction:

-   It reduces volatility.

-   It protects the bankroll from catastrophic drawdowns.

-   It produces much higher median (typical) growth.